import { type components } from '@octokit/openapi-types';
import { expectType } from 'ts-data-forge';
import * as t from 'ts-fortress';

const SimpleUser = t.strictRecord({
  name: t.optional(t.union([t.string(), t.nullType])),
  email: t.optional(t.union([t.string(), t.nullType])),
  login: t.string(),
  id: t.number(),
  node_id: t.string(),
  avatar_url: t.string(),
  gravatar_id: t.union([t.string(), t.nullType]),
  url: t.string(),
  html_url: t.string(),
  followers_url: t.string(),
  following_url: t.string(),
  gists_url: t.string(),
  starred_url: t.string(),
  subscriptions_url: t.string(),
  organizations_url: t.string(),
  repos_url: t.string(),
  events_url: t.string(),
  received_events_url: t.string(),
  type: t.string(),
  site_admin: t.boolean(),
  starred_at: t.optional(t.string()),
  user_view_type: t.optional(t.string()),
});

const NullableSimpleUser = t.union([SimpleUser, t.nullType]);

const NullableLicenseSimple = t.union([
  t.strictRecord({
    key: t.string(),
    name: t.string(),
    url: t.union([t.string(), t.nullType]),
    spdx_id: t.union([t.string(), t.nullType]),
    node_id: t.string(),
    html_url: t.optional(t.string()),
  }),
  t.nullType,
]);

const CodeOfConductSimple = t.strictRecord({
  url: t.string(),
  key: t.string(),
  name: t.string(),
  html_url: t.union([t.string(), t.nullType]),
});

const SecurityAndAnalysis = t.union([
  t.record(
    {
      advanced_security: t.optional(
        t.strictRecord({
          status: t.optional(t.enumType(['enabled', 'disabled'])),
        }),
      ),
      code_security: t.optional(
        t.strictRecord({
          status: t.optional(t.enumType(['enabled', 'disabled'])),
        }),
      ),
      dependabot_security_updates: t.optional(
        t.strictRecord({
          status: t.optional(t.enumType(['enabled', 'disabled'])),
        }),
      ),
      secret_scanning: t.optional(
        t.strictRecord({
          status: t.optional(t.enumType(['enabled', 'disabled'])),
        }),
      ),
      secret_scanning_push_protection: t.optional(
        t.strictRecord({
          status: t.optional(t.enumType(['enabled', 'disabled'])),
        }),
      ),
      secret_scanning_non_provider_patterns: t.optional(
        t.strictRecord({
          status: t.optional(t.enumType(['enabled', 'disabled'])),
        }),
      ),
      secret_scanning_ai_detection: t.optional(
        t.strictRecord({
          status: t.optional(t.enumType(['enabled', 'disabled'])),
        }),
      ),
    },
    {
      // NOTE: It may contain a key called "secret_scanning_validity_checks"
      allowExcessProperties: true,
    },
  ),
  t.nullType,
]);

const Repository = t.strictRecord({
  id: t.number(),
  node_id: t.string(),
  name: t.string(),
  full_name: t.string(),
  license: NullableLicenseSimple,
  forks: t.number(),
  permissions: t.optional(
    t.strictRecord({
      admin: t.boolean(),
      pull: t.boolean(),
      triage: t.optional(t.boolean()),
      push: t.boolean(),
      maintain: t.optional(t.boolean()),
    }),
  ),
  owner: SimpleUser,
  private: t.boolean(),
  html_url: t.string(),
  description: t.union([t.string(), t.nullType]),
  fork: t.boolean(),
  url: t.string(),
  archive_url: t.string(),
  assignees_url: t.string(),
  blobs_url: t.string(),
  branches_url: t.string(),
  collaborators_url: t.string(),
  comments_url: t.string(),
  commits_url: t.string(),
  compare_url: t.string(),
  contents_url: t.string(),
  contributors_url: t.string(),
  deployments_url: t.string(),
  downloads_url: t.string(),
  events_url: t.string(),
  forks_url: t.string(),
  git_commits_url: t.string(),
  git_refs_url: t.string(),
  git_tags_url: t.string(),
  git_url: t.string(),
  issue_comment_url: t.string(),
  issue_events_url: t.string(),
  issues_url: t.string(),
  keys_url: t.string(),
  labels_url: t.string(),
  languages_url: t.string(),
  merges_url: t.string(),
  milestones_url: t.string(),
  notifications_url: t.string(),
  pulls_url: t.string(),
  releases_url: t.string(),
  ssh_url: t.string(),
  stargazers_url: t.string(),
  statuses_url: t.string(),
  subscribers_url: t.string(),
  subscription_url: t.string(),
  tags_url: t.string(),
  teams_url: t.string(),
  trees_url: t.string(),
  clone_url: t.string(),
  mirror_url: t.union([t.string(), t.nullType]),
  hooks_url: t.string(),
  svn_url: t.string(),
  homepage: t.union([t.string(), t.nullType]),
  language: t.union([t.string(), t.nullType]),
  forks_count: t.number(),
  stargazers_count: t.number(),
  watchers_count: t.number(),
  size: t.number(),
  default_branch: t.string(),
  open_issues_count: t.number(),
  is_template: t.optional(t.boolean()),
  topics: t.optional(t.array(t.string())),
  has_issues: t.boolean(),
  has_projects: t.boolean(),
  has_wiki: t.boolean(),
  has_pages: t.boolean(),
  has_downloads: t.boolean(),
  has_discussions: t.optional(t.boolean()),
  archived: t.boolean(),
  disabled: t.boolean(),
  visibility: t.optional(t.string()),
  pushed_at: t.union([t.string(), t.nullType]),
  created_at: t.union([t.string(), t.nullType]),
  updated_at: t.union([t.string(), t.nullType]),
  allow_rebase_merge: t.optional(t.boolean()),
  temp_clone_token: t.optional(t.string()),
  allow_squash_merge: t.optional(t.boolean()),
  allow_auto_merge: t.optional(t.boolean()),
  delete_branch_on_merge: t.optional(t.boolean()),
  allow_update_branch: t.optional(t.boolean()),
  use_squash_pr_title_as_default: t.optional(t.boolean()),
  squash_merge_commit_title: t.optional(
    t.enumType(['PR_TITLE', 'COMMIT_OR_PR_TITLE']),
  ),
  squash_merge_commit_message: t.optional(
    t.enumType(['PR_BODY', 'COMMIT_MESSAGES', 'BLANK']),
  ),
  merge_commit_title: t.optional(t.enumType(['PR_TITLE', 'MERGE_MESSAGE'])),
  merge_commit_message: t.optional(
    t.enumType(['PR_BODY', 'PR_TITLE', 'BLANK']),
  ),
  allow_merge_commit: t.optional(t.boolean()),
  allow_forking: t.optional(t.boolean()),
  web_commit_signoff_required: t.optional(t.boolean()),
  open_issues: t.number(),
  watchers: t.number(),
  master_branch: t.optional(t.string()),
  starred_at: t.optional(t.string()),
  anonymous_access_enabled: t.optional(t.boolean()),
  code_search_index_status: t.optional(
    t.strictRecord({
      lexical_search_ok: t.optional(t.boolean()),
      lexical_commit_sha: t.optional(t.string()),
    }),
  ),
});

const NullableRepository = t.union([Repository, t.nullType]);

export const FullRepository = t.strictRecord({
  id: t.number(),
  node_id: t.string(),
  name: t.string(),
  full_name: t.string(),
  owner: SimpleUser,
  private: t.boolean(),
  html_url: t.string(),
  description: t.union([t.string(), t.nullType]),
  fork: t.boolean(),
  url: t.string(),
  archive_url: t.string(),
  assignees_url: t.string(),
  blobs_url: t.string(),
  branches_url: t.string(),
  collaborators_url: t.string(),
  comments_url: t.string(),
  commits_url: t.string(),
  compare_url: t.string(),
  contents_url: t.string(),
  contributors_url: t.string(),
  deployments_url: t.string(),
  downloads_url: t.string(),
  events_url: t.string(),
  forks_url: t.string(),
  git_commits_url: t.string(),
  git_refs_url: t.string(),
  git_tags_url: t.string(),
  git_url: t.string(),
  issue_comment_url: t.string(),
  issue_events_url: t.string(),
  issues_url: t.string(),
  keys_url: t.string(),
  labels_url: t.string(),
  languages_url: t.string(),
  merges_url: t.string(),
  milestones_url: t.string(),
  notifications_url: t.string(),
  pulls_url: t.string(),
  releases_url: t.string(),
  ssh_url: t.string(),
  stargazers_url: t.string(),
  statuses_url: t.string(),
  subscribers_url: t.string(),
  subscription_url: t.string(),
  tags_url: t.string(),
  teams_url: t.string(),
  trees_url: t.string(),
  clone_url: t.string(),
  mirror_url: t.union([t.string(), t.nullType]),
  hooks_url: t.string(),
  svn_url: t.string(),
  homepage: t.union([t.string(), t.nullType]),
  language: t.union([t.string(), t.nullType]),
  forks_count: t.number(),
  stargazers_count: t.number(),
  watchers_count: t.number(),
  size: t.number(),
  default_branch: t.string(),
  open_issues_count: t.number(),
  is_template: t.optional(t.boolean()),
  topics: t.optional(t.array(t.string())),
  has_issues: t.boolean(),
  has_projects: t.boolean(),
  has_wiki: t.boolean(),
  has_pages: t.boolean(),
  has_downloads: t.optional(t.boolean()),
  has_discussions: t.boolean(),
  archived: t.boolean(),
  disabled: t.boolean(),
  visibility: t.optional(t.string()),
  pushed_at: t.string(),
  created_at: t.string(),
  updated_at: t.string(),
  permissions: t.optional(
    t.strictRecord({
      admin: t.boolean(),
      maintain: t.optional(t.boolean()),
      push: t.boolean(),
      triage: t.optional(t.boolean()),
      pull: t.boolean(),
    }),
  ),
  template_repository: t.optional(NullableRepository),
  temp_clone_token: t.optional(t.union([t.string(), t.nullType])),
  allow_squash_merge: t.optional(t.boolean()),
  allow_rebase_merge: t.optional(t.boolean()),
  allow_merge_commit: t.optional(t.boolean()),
  allow_auto_merge: t.optional(t.boolean()),
  delete_branch_on_merge: t.optional(t.boolean()),
  allow_update_branch: t.optional(t.boolean()),
  use_squash_pr_title_as_default: t.optional(t.boolean()),
  squash_merge_commit_title: t.optional(
    t.enumType(['PR_TITLE', 'COMMIT_OR_PR_TITLE']),
  ),
  squash_merge_commit_message: t.optional(
    t.enumType(['PR_BODY', 'COMMIT_MESSAGES', 'BLANK']),
  ),
  merge_commit_title: t.optional(t.enumType(['PR_TITLE', 'MERGE_MESSAGE'])),
  merge_commit_message: t.optional(
    t.enumType(['PR_BODY', 'PR_TITLE', 'BLANK']),
  ),
  allow_forking: t.optional(t.boolean()),
  web_commit_signoff_required: t.optional(t.boolean()),
  subscribers_count: t.number(),
  network_count: t.number(),
  license: NullableLicenseSimple,
  organization: t.optional(NullableSimpleUser),
  parent: t.optional(Repository),
  source: t.optional(Repository),
  forks: t.number(),
  master_branch: t.optional(t.string()),
  open_issues: t.number(),
  watchers: t.number(),
  anonymous_access_enabled: t.optional(t.boolean()),
  code_of_conduct: t.optional(CodeOfConductSimple),
  security_and_analysis: t.optional(SecurityAndAnalysis),
  custom_properties: t.optional(t.keyValueRecord(t.string(), t.unknown())),
});

export type FullRepository = t.TypeOf<typeof FullRepository>;

expectType<
  FullRepository,
  DeepReadonly<components['schemas']['full-repository']>
>('=');
